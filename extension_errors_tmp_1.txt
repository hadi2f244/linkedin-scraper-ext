```
Error getting Copilot token: Error: Access denied to GitHub Copilot API. Make sure you have an active GitHub Copilot subscription. Visit https://github.com/settings/copilot to check your subscription status.
Context
sidepanel.html
Stack Trace
copilot-auth.js:180 (getCopilotToken)

// GitHub Copilot Authentication and Chat Module
// Converted from Python implementation to JavaScript

const COPILOT_CLIENT_ID = 'Iv1.b507a08c87ecfe98';
const COPILOT_MODEL = 'gpt-4o';

class CopilotAuth {
    constructor() {
        this.token = null;
        this.messages = [];
    }

    /**
     * Initiate GitHub device flow authentication
     * Returns device code, user code, and verification URI
     */
    async initiateDeviceFlow() {
        try {
            const response = await fetch('https://github.com/login/device/code', {
                method: 'POST',
                headers: {
                    'accept': 'application/json',
                    'editor-version': 'Neovim/0.6.1',
                    'editor-plugin-version': 'copilot.vim/1.16.0',
                    'content-type': 'application/json',
                    'user-agent': 'GithubCopilot/1.155.0',
                    'accept-encoding': 'gzip,deflate,br'
                },
                body: JSON.stringify({
                    client_id: COPILOT_CLIENT_ID,
                    scope: 'read:user'
                })
            });

            if (!response.ok) {
                throw new Error(`Failed to initiate device flow: ${response.status}`);
            }

            const data = await response.json();
            return {
                deviceCode: data.device_code,
                userCode: data.user_code,
                verificationUri: data.verification_uri,
                expiresIn: data.expires_in,
                interval: data.interval || 5
            };
        } catch (error) {
            console.error('Error initiating device flow:', error);
            throw error;
        }
    }

    /**
     * Poll for access token after user authorizes
     */
    async pollForAccessToken(deviceCode, interval = 5, maxAttempts = 60) {
        let attempts = 0;

        while (attempts < maxAttempts) {
            attempts++;

            // Wait before polling
            await new Promise(resolve => setTimeout(resolve, interval * 1000));

            try {
                const response = await fetch('https://github.com/login/oauth/access_token', {
                    method: 'POST',
                    headers: {
                        'accept': 'application/json',
                        'editor-version': 'Neovim/0.6.1',
                        'editor-plugin-version': 'copilot.vim/1.16.0',
                        'content-type': 'application/json',
                        'user-agent': 'GithubCopilot/1.155.0',
                        'accept-encoding': 'gzip,deflate,br'
                    },
                    body: JSON.stringify({
                        client_id: COPILOT_CLIENT_ID,
                        device_code: deviceCode,
                        grant_type: 'urn:ietf:params:oauth:grant-type:device_code'
                    })
                });

                if (!response.ok) {
                    throw new Error(`Failed to poll for token: ${response.status}`);
                }

                const data = await response.json();

                // Check for errors
                if (data.error) {
                    if (data.error === 'authorization_pending') {
                        // User hasn't authorized yet, continue polling
                        continue;
                    } else if (data.error === 'slow_down') {
                        // Increase interval
                        interval += 5;
                        continue;
                    } else if (data.error === 'expired_token') {
                        throw new Error('Device code expired. Please try again.');
                    } else if (data.error === 'access_denied') {
                        throw new Error('Access denied by user.');
                    } else {
                        throw new Error(`OAuth error: ${data.error}`);
                    }
                }

                // Success - we have an access token
                if (data.access_token) {
                    return data.access_token;
                }

            } catch (error) {
                console.error('Error polling for token:', error);
                throw error;
            }
        }

        throw new Error('Timeout waiting for user authorization');
    }

    /**
     * Save access token to Chrome storage
     */
    async saveAccessToken(accessToken) {
        await chrome.storage.local.set({
            COPILOT_ACCESS_TOKEN: accessToken,
            COPILOT_TOKEN_DATE: new Date().toISOString()
        });
    }

    /**
     * Load access token from Chrome storage
     */
    async loadAccessToken() {
        const result = await chrome.storage.local.get(['COPILOT_ACCESS_TOKEN']);
        return result.COPILOT_ACCESS_TOKEN || null;
    }

    /**
     * Get Copilot session token using access token
     */
    async getCopilotToken(accessToken) {
        try {
            const response = await fetch('https://api.github.com/copilot_internal/v2/token', {
                method: 'GET',
                headers: {
                    'authorization': `token ${accessToken}`,
                    'editor-version': 'Neovim/0.6.1',
                    'editor-plugin-version': 'copilot.vim/1.16.0',
                    'user-agent': 'GithubCopilot/1.155.0'
                }
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));

                // Handle specific error cases
                if (response.status === 403) {
                    if (errorData.error_details?.notification_id === 'feature_flag_blocked') {
                        throw new Error(
                            'GitHub Copilot is not enabled for your account. ' +
                            'Please subscribe to GitHub Copilot at https://github.com/features/copilot or ' +
                            'switch to OpenAI/Groq in the extension options.'
                        );
                    }
                    throw new Error(
                        'Access denied to GitHub Copilot API. ' +
                        'Make sure you have an active GitHub Copilot subscription. ' +
                        'Visit https://github.com/settings/copilot to check your subscription status.'
                    );
                }

                throw new Error(`Failed to get Copilot token: ${response.status} - ${errorData.message || 'Unknown error'}`);
            }

            const data = await response.json();
            this.token = data.token;
            return data.token;
        } catch (error) {
            console.error('Error getting Copilot token:', error);
```

```
[Badge Scanner] Error checking CSV database: Error: Extension context invalidated.
Context
https://www.linkedin.com/jobs/collections/recommended/?currentJobId=4226335125
Stack Trace
content.js:577 (checkVisaSponsorship)
...

...
<77 lines not shown>
  }

  // For longer names, check if the search name is contained in CSV name
  // But only if it's at the start (to avoid false matches)
  if (core1.length > 5 && n2.startsWith(core1)) {
    return true;
  }

  if (core2.length > 5 && n1.startsWith(core2)) {
    return true;
  }

  return false;
};

// Search companies via background script (content scripts can't access extension IndexedDB)
const searchCompaniesInIndexedDB = async (companyName) => {
  try {
    console.log('[Badge Scanner] Sending search request to background script for:', companyName);

    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage(
        { type: 'SEARCH_VISA_SPONSOR', companyName },
        (response) => {
          if (chrome.runtime.lastError) {
            console.error('[Badge Scanner] Message error:', chrome.runtime.lastError);
            reject(chrome.runtime.lastError);
            return;
          }

          if (response && response.success) {
            console.log('[Badge Scanner] Received matches from background:', response.matches.length);
            resolve(response.matches);
          } else {
            console.error('[Badge Scanner] Search failed:', response?.error);
            resolve([]);
          }
        }
      );
    });
  } catch (error) {
    console.error('[Badge Scanner] Error searching IndexedDB:', error);
    return [];
  }
};

// Extract company name from the page
const extractCompanyName = () => {
  console.log('[LinkedIn Scraper] Attempting to extract company name...');

  // Try multiple selectors in order of reliability
  const selectors = [
    // Primary - the div with class and anchor inside
    { selector: '.job-details-jobs-unified-top-card__company-name a', name: 'Primary (div.company-name > a)' },
    { selector: '.job-details-jobs-unified-top-card__company-name', name: 'Primary (div.company-name)', getAnchor: true },
    // Alternative - look for any anchor with company link in the top card area
    { selector: '.job-details-jobs-unified-top-card__container--two-pane a[href*="/company/"]', name: 'Top card company link' },
    { selector: '.display-flex.align-items-center.flex-1 > div > a', name: 'Flex container anchor' },
    // Fallbacks
    { selector: '.jobs-unified-top-card__company-name a', name: 'Fallback 1' },
    { selector: '.jobs-unified-top-card__company-name', name: 'Fallback 2', getAnchor: true },
    { selector: 'a[data-tracking-control-name="public_jobs_topcard-org-name"]', name: 'Fallback 3' },
  ];

  for (const { selector, name, getAnchor } of selectors) {
    console.log(`[LinkedIn Scraper] Trying selector: ${name} (${selector})`);
    let el = document.querySelector(selector);

    if (el) {
      console.log(`[LinkedIn Scraper] Element found:`, el);

      // If we need to get anchor from inside the element
      if (getAnchor) {
        const anchor = el.querySelector('a');
        if (anchor) {
          el = anchor;
          console.log(`[LinkedIn Scraper] Found anchor inside:`, anchor);
        }
      }

      let companyName = (el.innerText || el.textContent || '').trim();
      console.log(`[LinkedIn Scraper] Raw text: "${companyName}"`);

      // Clean up the text
      companyName = companyName
        .replace(/\s*·\s*Follow\s*/gi, '')
        .replace(/\s*Follow\s*/gi, '')
        .replace(/\n/g, ' ')
        .trim();

      console.log(`[LinkedIn Scraper] Cleaned text: "${companyName}"`);

      if (companyName && companyName.length > 0 && companyName.length < 100) {
        console.log(`[LinkedIn Scraper] ✓ SUCCESS! Found company name: "${companyName}" using ${name}`);
        return companyName;
      }
    } else {
      console.log(`[LinkedIn Scraper] Element not found for: ${name}`);
    }
  }

  console.log('[LinkedIn Scraper] ❌ FAILED - Could not find company name with any selector');
  console.log('[LinkedIn Scraper] Available elements with "company" in class:',
    Array.from(document.querySelectorAll('[class*="company"]')).map(el => ({
      tag: el.tagName,
      class: el.className,
      text: (el.innerText || el.textContent || '').substring(0, 50)
    }))
  );

  return null;
};

// Wait for company name element to appear
const waitForCompanyName = (timeout = 3000) => {
  console.log('[LinkedIn Scraper] waitForCompanyName() called, timeout:', timeout);
  return new Promise((resolve) => {
    const startTime = Date.now();
    let attemptCount = 0;

    const checkCompanyName = () => {
      attemptCount++;
      console.log(`[LinkedIn Scraper] Attempt ${attemptCount} to extract company name...`);
      const companyName = extractCompanyName();

      if (companyName) {
        console.log(`[LinkedIn Scraper] ✓ Company name found after ${attemptCount} attempts:`, companyName);
        resolve(companyName);
        return;
      }

      // Keep trying until timeout
      const elapsed = Date.now() - startTime;
      if (elapsed < timeout) {
        console.log(`[LinkedIn Scraper] Retrying in 200ms... (${elapsed}ms elapsed)`);
        setTimeout(checkCompanyName, 200);
      } else {
        console.log(`[LinkedIn Scraper] ⏱ Timeout after ${attemptCount} attempts (${elapsed}ms)`);
        resolve(null);
      }
    };

    checkCompanyName();
  });
};

// Extract job details from the page
const extractJobDetails = async () => {
  console.log('[LinkedIn Scraper] extractJobDetails() called');

  // Based on actual HTML: .jobs-search__job-details--wrapper contains the job description
  const jobDetailsEl = document.querySelector('.jobs-search__job-details--wrapper') ||
                       document.querySelector('#job-details > div');

  if (!jobDetailsEl) {
    console.log('[LinkedIn Scraper] No job details element found');
    return null;
  }

  const text = jobDetailsEl.innerText || jobDetailsEl.textContent || '';
  const cleaned = normalizeText(text);

  // Extract job ID from URL - try multiple patterns
  const url = window.location.href;
  console.log('[Badge Scanner] Current URL:', url);

  let jobId = null;

  // Try different URL patterns
  const patterns = [
    /\/jobs\/view\/(\d+)/,           // /jobs/view/123456
    /\/jobs\/collections\/[^/]+\/(\d+)/, // /jobs/collections/recommended/123456
    /currentJobId=(\d+)/,             // ?currentJobId=123456
    /\/jobs\/search\/[^/]*\?currentJobId=(\d+)/, // /jobs/search/?currentJobId=123456
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      jobId = match[1];
      console.log('[Badge Scanner] Job ID extracted using pattern:', pattern, '→', jobId);
      break;
    }
  }

  if (!jobId) {
    console.log('[Badge Scanner] Could not extract job ID from URL');
  }

  // Only send if the content has changed
  if (cleaned && cleaned !== lastJobText) {
    console.log('[LinkedIn Scraper] New job text detected, length:', cleaned.length);
    lastJobText = cleaned;
    currentJobId = jobId;

    // Wait for company name to load (with timeout)
    console.log('[LinkedIn Scraper] Starting company name extraction...');
    const companyName = await waitForCompanyName(3000);
    console.log('[LinkedIn Scraper] Final company name:', companyName);

    // Trigger badge analysis for this job
    console.log('[Badge Scanner] Checking if should analyze job...');
    console.log('[Badge Scanner] - jobId:', jobId);
    console.log('[Badge Scanner] - badgeSettings:', badgeSettings);
    console.log('[Badge Scanner] - badgeSettings.enabled:', badgeSettings?.enabled);

    if (jobId && badgeSettings && badgeSettings.enabled) {
      console.log('[Badge Scanner] ✓ Triggering badge analysis');
      await analyzeCurrentJobAndUpdateBadges(jobId, cleaned);
    } else {
      console.log('[Badge Scanner] ✗ Skipping badge analysis');
      if (!jobId) console.log('[Badge Scanner]   - No job ID');
      if (!badgeSettings) console.log('[Badge Scanner]   - Badge settings not loaded');
      if (badgeSettings && !badgeSettings.enabled) console.log('[Badge Scanner]   - Badge scanner disabled');
    }

    return {
      text: cleaned,
      companyName: companyName
    };
  }

  console.log('[LinkedIn Scraper] Job text unchanged, skipping');
  return null;
};

// Send job data to the side panel
const sendJobDataToSidePanel = (jobData) => {
  chrome.runtime.sendMessage({
    type: 'JOB_DATA_UPDATED',
    data: {
      text: jobData.text,
      companyName: jobData.companyName,
      url: window.location.href,
      timestamp: Date.now()
    }
  }).catch((err) => {
    // Side panel might not be open yet, that's okay
    console.log('Could not send to side panel:', err.message);
  });
};

// Check for job details and send if found
const checkAndSendJobDetails = async () => {
  const jobData = await extractJobDetails();
  if (jobData) {
    console.log('Job details found, sending to side panel');
    console.log('Company name in job data:', jobData.companyName);
    sendJobDataToSidePanel(jobData);
  }
};

// Set up observer to watch for DOM changes
const setupObserver = () => {
  if (observerActive) return;

  const targetNode = document.body;
  const config = { childList: true, subtree: true };

  const callback = (mutationsList, observer) => {
    // Debounce: check for job details after mutations
    clearTimeout(window.jobCheckTimeout);
    window.jobCheckTimeout = setTimeout(() => {
      checkAndSendJobDetails();
    }, 500);
  };

  const observer = new MutationObserver(callback);
  observer.observe(targetNode, config);
  observerActive = true;

  console.log('LinkedIn job observer started');
};

// Initialize when page loads
const init = () => {
  console.log('LinkedIn Job Scraper content script loaded');

  // Check immediately
  setTimeout(checkAndSendJobDetails, 1000);

  // Set up observer for future changes
  setupObserver();

  // Also check when user scrolls (in case they scroll through job list)
  let scrollTimeout;
  window.addEventListener('scroll', () => {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(checkAndSendJobDetails, 300);
  }, { passive: true });

  // Listen for clicks on job listings
  document.addEventListener('click', (e) => {
    // Check if clicked element is or is within a job card
    const jobCard = e.target.closest('.job-card-container, .jobs-search-results__list-item');
    if (jobCard) {
      setTimeout(checkAndSendJobDetails, 500);
    }
  }, true);
};

// Start when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

// Listen for messages from side panel (e.g., requesting current job data)
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.type === 'REQUEST_JOB_DATA') {
    // Handle async extraction
    extractJobDetails().then(jobData => {
      sendResponse({
        success: true,
        data: jobData ? {
          text: jobData.text,
          companyName: jobData.companyName,
          url: window.location.href,
          timestamp: Date.now()
        } : null
      });
    });
    return true; // Keep the message channel open for async response
  }
  return true;
});

// ============================================================================
// BADGE SCANNER MODULE - Scans job listings and displays badges
// ============================================================================

// Load badge settings from storage
const loadBadgeSettings = async () => {
  const settings = await chrome.storage.local.get([
    'ENABLE_BADGE_SCANNER',
    'ENABLE_VISA_BADGE',
    'BADGE_KEYWORDS'
  ]);

  // Parse badge keywords
  const badgeKeywords = [];
  if (settings.BADGE_KEYWORDS) {
    const lines = settings.BADGE_KEYWORDS.split('\n');
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed) {
        const parts = trimmed.split('|');
        const keyword = parts[0]?.trim().toLowerCase();
        const color = parts[1]?.trim() || '#2196f3'; // Default blue
        if (keyword) {
          badgeKeywords.push({ keyword, color });
        }
      }
    }
  }

  badgeSettings = {
    enabled: settings.ENABLE_BADGE_SCANNER === true, // Explicitly check for true
    visaBadgeEnabled: settings.ENABLE_VISA_BADGE !== false, // Default true
    keywords: badgeKeywords
  };

  console.log('[Badge Scanner] Settings loaded:', badgeSettings);
  console.log('[Badge Scanner] Raw ENABLE_BADGE_SCANNER value:', settings.ENABLE_BADGE_SCANNER);
  return badgeSettings;
};

// Get all job listing cards in the left panel
const getJobListingCards = () => {
  console.log('[Badge Scanner] getJobListingCards() called');

  // Based on actual LinkedIn HTML: li.scaffold-layout__list-item with data-occludable-job-id
  const cards = document.querySelectorAll('li.scaffold-layout__list-item[data-occludable-job-id]');

  console.log(`[Badge Scanner] Selector: li.scaffold-layout__list-item[data-occludable-job-id]`);
  console.log(`[Badge Scanner] Found ${cards.length} job cards`);

  if (cards.length > 0) {
    // Log first card for debugging
    console.log('[Badge Scanner] First card:', cards[0]);
    console.log('[Badge Scanner] First card job ID:', cards[0].getAttribute('data-occludable-job-id'));
    return Array.from(cards);
  }

  console.log('[Badge Scanner] ⚠️ No job cards found! Checking if page structure exists...');
  const listContainer = document.querySelector('.scaffold-layout__list');
  console.log('[Badge Scanner] List container exists:', !!listContainer);

  return [];
};

// Extract job ID from a job card
const getJobIdFromCard = (card) => {
  // Based on actual HTML: data-occludable-job-id on the li element
  let jobId = card.getAttribute('data-occludable-job-id');

  if (jobId) {
    console.log(`[Badge Scanner] Extracted job ID from data attribute: ${jobId}`);
    return jobId;
  }

  // Fallback: try to get from the inner div's data-job-id attribute
  const innerDiv = card.querySelector('[data-job-id]');
  if (innerDiv) {
    jobId = innerDiv.getAttribute('data-job-id');
    console.log(`[Badge Scanner] Extracted job ID from inner div: ${jobId}`);
    return jobId;
  }

  // Last resort: extract from link href
  const link = card.querySelector('a.job-card-container__link');
  if (link && link.href) {
    const match = link.href.match(/\/jobs\/view\/(\d+)/);
    if (match) {
      console.log(`[Badge Scanner] Extracted job ID from link: ${match[1]}`);
      return match[1];
    }
  }

  console.log('[Badge Scanner] Could not extract job ID from card');
  return null;
};

// Extract company name from a job card
const getCompanyNameFromCard = (card) => {
  console.log('[Badge Scanner] Attempting to extract company name from card...');

  // Try multiple selectors for company name in job cards
  const selectors = [
    '.job-card-container__primary-description', // Common location for company name
    '.artdeco-entity-lockup__subtitle',
    '.job-card-container__company-name',
    '[data-job-card-company-name]',
    '.job-card-list__entity-lockup .artdeco-entity-lockup__subtitle'
  ];

  for (const selector of selectors) {
    const element = card.querySelector(selector);
    if (element) {
      let companyName = (element.innerText || element.textContent || '').trim();

      // Clean up the text
      companyName = companyName
        .replace(/\s*·\s*Follow\s*/gi, '')
        .replace(/\s*Follow\s*/gi, '')
        .replace(/\n/g, ' ')
        .trim();

      if (companyName && companyName.length > 0 && companyName.length < 100) {
        console.log(`[Badge Scanner] ✓ Found company name from card: "${companyName}" using ${selector}`);
        return companyName;
      }
    }
  }

  console.log('[Badge Scanner] Could not extract company name from card');
  return null;
};

// Check if job description contains visa sponsorship keywords OR company is in CSV
const checkVisaSponsorship = async (jobText, companyName) => {
  console.log(`[Badge Scanner] checkVisaSponsorship called with company: "${companyName}"`);

  // First check: Look for visa keywords in job description
  const visaKeywords = [
    'visa sponsorship',
    'visa sponsor',
    'sponsorship available',
    'will sponsor',
    'can sponsor',
    'sponsorship provided',
    'h1b',
    'h-1b',
    'work authorization',
    'right to work'
  ];

  const lowerText = jobText.toLowerCase();
  const hasVisaKeywords = visaKeywords.some(keyword => lowerText.includes(keyword));

  if (hasVisaKeywords) {
    console.log(`[Badge Scanner] ✓ Visa keywords found in job description`);
    return true;
  }

  // Second check: Look up company in CSV database
  if (companyName && companyName.trim()) {
    console.log(`[Badge Scanner] Checking CSV database for company: "${companyName}"`);
    try {
      const matches = await searchCompaniesInIndexedDB(companyName);
      if (matches && matches.length > 0) {
        console.log(`[Badge Scanner] ✓ Company found in CSV database with ${matches.length} matches`);
        console.log(`[Badge Scanner] Top match: ${matches[0]['Organisation Name']}`);
        return true;
      } else {
        console.log(`[Badge Scanner] Company not found in CSV database`);
      }
    } catch (error) {
      console.error(`[Badge Scanner] Error checking CSV database:`, error);
    }
  } else {
    console.log(`[Badge Scanner] No company name provided for CSV check`);
```

```
Uncaught (in promise) Error: Extension context invalidated.
Context
https://www.linkedin.com/jobs/collections/recommended/?currentJobId=4295683426
Stack Trace
content.js:306 (sendJobDataToSidePanel)
content.js:326 (checkAndSendJobDetails)

...
// Content script for LinkedIn job pages
// Monitors job details and sends updates to the side panel

let lastJobText = '';
let observerActive = false;
let badgeScannerActive = false;
let scannedJobs = new Map(); // Track which jobs have been scanned with their badge data
let badgeSettings = null; // Cache badge settings
let currentJobId = null; // Track currently viewed job

// Normalize text function (same as in popup.js)
const normalizeText = (t) => {
  if (!t) {
    return '';
  }
  return t
    .replace(/\u00A0/g, ' ')         // non-breaking spaces -> normal spaces
    .replace(/\r/g, '')              // CR
    .replace(/[ \t]+\n/g, '\n')      // trailing spaces before newline
    .replace(/\n{3,}/g, '\n\n')      // more than 2 empty lines -> 1 empty line
    .replace(/[ \t]{2,}/g, ' ')      // multiple spaces
    .trim();
};

// Normalize company name for comparison
const normalizeCompanyName = (name) => {
  if (!name) return '';
  return name
    .toLowerCase()
    .replace(/\s+/g, ' ')
    .replace(/[^\w\s&]/g, '')
    .trim();
};

// Extract core company name (remove common suffixes)
const extractCoreCompanyName = (name) => {
  if (!name) return '';

  let core = normalizeCompanyName(name);

  // Remove common company suffixes
  const suffixes = [
    'limited', 'ltd', 'plc', 'llc', 'inc', 'incorporated',
    'corporation', 'corp', 'company', 'co', 'group', 'holdings',
    'international', 'intl', 'uk', 'usa', 'us', 'europe', 'global'
  ];

  // Remove suffixes from the end
  for (const suffix of suffixes) {
    const regex = new RegExp(`\\s+${suffix}$`, 'gi');
    core = core.replace(regex, '').trim();
  }

  return core;
};

// Check if two company names match (strict matching)
const companyNamesMatch = (searchName, csvName) => {
  const n1 = normalizeCompanyName(searchName);
  const n2 = normalizeCompanyName(csvName);

  if (!n1 || !n2) return false;

  // Exact match after normalization
  if (n1 === n2) return true;

  // Extract core names (without suffixes)
  const core1 = extractCoreCompanyName(searchName);
  const core2 = extractCoreCompanyName(csvName);

  // Core names must match exactly
  if (core1 === core2 && core1.length > 0) return true;

  // For very short names (like "Teya"), require exact match of the core
  if (core1.length <= 5 || core2.length <= 5) {
    // Only match if one core is exactly the other (not just contains)
    return core1 === core2;
  }

  // For longer names, check if the search name is contained in CSV name
  // But only if it's at the start (to avoid false matches)
  if (core1.length > 5 && n2.startsWith(core1)) {
    return true;
  }

  if (core2.length > 5 && n1.startsWith(core2)) {
    return true;
  }

  return false;
};

// Search companies via background script (content scripts can't access extension IndexedDB)
const searchCompaniesInIndexedDB = async (companyName) => {
  try {
    console.log('[Badge Scanner] Sending search request to background script for:', companyName);

    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage(
        { type: 'SEARCH_VISA_SPONSOR', companyName },
        (response) => {
          if (chrome.runtime.lastError) {
            console.error('[Badge Scanner] Message error:', chrome.runtime.lastError);
            reject(chrome.runtime.lastError);
            return;
          }

          if (response && response.success) {
            console.log('[Badge Scanner] Received matches from background:', response.matches.length);
            resolve(response.matches);
          } else {
            console.error('[Badge Scanner] Search failed:', response?.error);
            resolve([]);
          }
        }
      );
    });
  } catch (error) {
    console.error('[Badge Scanner] Error searching IndexedDB:', error);
    return [];
  }
};

// Extract company name from the page
const extractCompanyName = () => {
  console.log('[LinkedIn Scraper] Attempting to extract company name...');

  // Try multiple selectors in order of reliability
  const selectors = [
    // Primary - the div with class and anchor inside
    { selector: '.job-details-jobs-unified-top-card__company-name a', name: 'Primary (div.company-name > a)' },
    { selector: '.job-details-jobs-unified-top-card__company-name', name: 'Primary (div.company-name)', getAnchor: true },
    // Alternative - look for any anchor with company link in the top card area
    { selector: '.job-details-jobs-unified-top-card__container--two-pane a[href*="/company/"]', name: 'Top card company link' },
    { selector: '.display-flex.align-items-center.flex-1 > div > a', name: 'Flex container anchor' },
    // Fallbacks
    { selector: '.jobs-unified-top-card__company-name a', name: 'Fallback 1' },
    { selector: '.jobs-unified-top-card__company-name', name: 'Fallback 2', getAnchor: true },
    { selector: 'a[data-tracking-control-name="public_jobs_topcard-org-name"]', name: 'Fallback 3' },
  ];

  for (const { selector, name, getAnchor } of selectors) {
    console.log(`[LinkedIn Scraper] Trying selector: ${name} (${selector})`);
    let el = document.querySelector(selector);

    if (el) {
      console.log(`[LinkedIn Scraper] Element found:`, el);

      // If we need to get anchor from inside the element
      if (getAnchor) {
        const anchor = el.querySelector('a');
        if (anchor) {
          el = anchor;
          console.log(`[LinkedIn Scraper] Found anchor inside:`, anchor);
        }
      }

      let companyName = (el.innerText || el.textContent || '').trim();
      console.log(`[LinkedIn Scraper] Raw text: "${companyName}"`);

      // Clean up the text
      companyName = companyName
        .replace(/\s*·\s*Follow\s*/gi, '')
        .replace(/\s*Follow\s*/gi, '')
        .replace(/\n/g, ' ')
        .trim();

      console.log(`[LinkedIn Scraper] Cleaned text: "${companyName}"`);

      if (companyName && companyName.length > 0 && companyName.length < 100) {
        console.log(`[LinkedIn Scraper] ✓ SUCCESS! Found company name: "${companyName}" using ${name}`);
        return companyName;
      }
    } else {
      console.log(`[LinkedIn Scraper] Element not found for: ${name}`);
    }
  }

  console.log('[LinkedIn Scraper] ❌ FAILED - Could not find company name with any selector');
  console.log('[LinkedIn Scraper] Available elements with "company" in class:',
    Array.from(document.querySelectorAll('[class*="company"]')).map(el => ({
      tag: el.tagName,
      class: el.className,
      text: (el.innerText || el.textContent || '').substring(0, 50)
    }))
  );

  return null;
};

// Wait for company name element to appear
const waitForCompanyName = (timeout = 3000) => {
  console.log('[LinkedIn Scraper] waitForCompanyName() called, timeout:', timeout);
  return new Promise((resolve) => {
    const startTime = Date.now();
    let attemptCount = 0;

    const checkCompanyName = () => {
      attemptCount++;
      console.log(`[LinkedIn Scraper] Attempt ${attemptCount} to extract company name...`);
      const companyName = extractCompanyName();

      if (companyName) {
        console.log(`[LinkedIn Scraper] ✓ Company name found after ${attemptCount} attempts:`, companyName);
        resolve(companyName);
        return;
      }

      // Keep trying until timeout
      const elapsed = Date.now() - startTime;
      if (elapsed < timeout) {
        console.log(`[LinkedIn Scraper] Retrying in 200ms... (${elapsed}ms elapsed)`);
        setTimeout(checkCompanyName, 200);
      } else {
        console.log(`[LinkedIn Scraper] ⏱ Timeout after ${attemptCount} attempts (${elapsed}ms)`);
        resolve(null);
      }
    };

    checkCompanyName();
  });
};

// Extract job details from the page
const extractJobDetails = async () => {
  console.log('[LinkedIn Scraper] extractJobDetails() called');

  // Based on actual HTML: .jobs-search__job-details--wrapper contains the job description
  const jobDetailsEl = document.querySelector('.jobs-search__job-details--wrapper') ||
                       document.querySelector('#job-details > div');

  if (!jobDetailsEl) {
    console.log('[LinkedIn Scraper] No job details element found');
    return null;
  }

  const text = jobDetailsEl.innerText || jobDetailsEl.textContent || '';
  const cleaned = normalizeText(text);

  // Extract job ID from URL - try multiple patterns
  const url = window.location.href;
  console.log('[Badge Scanner] Current URL:', url);

  let jobId = null;

  // Try different URL patterns
  const patterns = [
    /\/jobs\/view\/(\d+)/,           // /jobs/view/123456
    /\/jobs\/collections\/[^/]+\/(\d+)/, // /jobs/collections/recommended/123456
    /currentJobId=(\d+)/,             // ?currentJobId=123456
    /\/jobs\/search\/[^/]*\?currentJobId=(\d+)/, // /jobs/search/?currentJobId=123456
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      jobId = match[1];
      console.log('[Badge Scanner] Job ID extracted using pattern:', pattern, '→', jobId);
      break;
    }
  }

  if (!jobId) {
    console.log('[Badge Scanner] Could not extract job ID from URL');
  }

  // Only send if the content has changed
  if (cleaned && cleaned !== lastJobText) {
    console.log('[LinkedIn Scraper] New job text detected, length:', cleaned.length);
    lastJobText = cleaned;
    currentJobId = jobId;

    // Wait for company name to load (with timeout)
    console.log('[LinkedIn Scraper] Starting company name extraction...');
    const companyName = await waitForCompanyName(3000);
    console.log('[LinkedIn Scraper] Final company name:', companyName);

    // Trigger badge analysis for this job
    console.log('[Badge Scanner] Checking if should analyze job...');
    console.log('[Badge Scanner] - jobId:', jobId);
    console.log('[Badge Scanner] - badgeSettings:', badgeSettings);
    console.log('[Badge Scanner] - badgeSettings.enabled:', badgeSettings?.enabled);

    if (jobId && badgeSettings && badgeSettings.enabled) {
      console.log('[Badge Scanner] ✓ Triggering badge analysis');
      await analyzeCurrentJobAndUpdateBadges(jobId, cleaned);
    } else {
      console.log('[Badge Scanner] ✗ Skipping badge analysis');
      if (!jobId) console.log('[Badge Scanner]   - No job ID');
      if (!badgeSettings) console.log('[Badge Scanner]   - Badge settings not loaded');
      if (badgeSettings && !badgeSettings.enabled) console.log('[Badge Scanner]   - Badge scanner disabled');
    }

    return {
      text: cleaned,
      companyName: companyName
    };
  }

  console.log('[LinkedIn Scraper] Job text unchanged, skipping');
  return null;
};

// Send job data to the side panel
const sendJobDataToSidePanel = (jobData) => {
  chrome.runtime.sendMessage({
    type: 'JOB_DATA_UPDATED',
    data: {
      text: jobData.text,
      companyName: jobData.companyName,
      url: window.location.href,
```

```
Uncaught (in promise) Error: Extension context invalidated.
Context
https://www.linkedin.com/jobs/collections/recommended/?currentJobId=4291121207
Stack Trace
content.js:306 (sendJobDataToSidePanel)
content.js:326 (checkAndSendJobDetails)

...
// Content script for LinkedIn job pages
// Monitors job details and sends updates to the side panel

let lastJobText = '';
let observerActive = false;
let badgeScannerActive = false;
let scannedJobs = new Map(); // Track which jobs have been scanned with their badge data
let badgeSettings = null; // Cache badge settings
let currentJobId = null; // Track currently viewed job

// Normalize text function (same as in popup.js)
const normalizeText = (t) => {
  if (!t) {
    return '';
  }
  return t
    .replace(/\u00A0/g, ' ')         // non-breaking spaces -> normal spaces
    .replace(/\r/g, '')              // CR
    .replace(/[ \t]+\n/g, '\n')      // trailing spaces before newline
    .replace(/\n{3,}/g, '\n\n')      // more than 2 empty lines -> 1 empty line
    .replace(/[ \t]{2,}/g, ' ')      // multiple spaces
    .trim();
};

// Normalize company name for comparison
const normalizeCompanyName = (name) => {
  if (!name) return '';
  return name
    .toLowerCase()
    .replace(/\s+/g, ' ')
    .replace(/[^\w\s&]/g, '')
    .trim();
};

// Extract core company name (remove common suffixes)
const extractCoreCompanyName = (name) => {
  if (!name) return '';

  let core = normalizeCompanyName(name);

  // Remove common company suffixes
  const suffixes = [
    'limited', 'ltd', 'plc', 'llc', 'inc', 'incorporated',
    'corporation', 'corp', 'company', 'co', 'group', 'holdings',
    'international', 'intl', 'uk', 'usa', 'us', 'europe', 'global'
  ];

  // Remove suffixes from the end
  for (const suffix of suffixes) {
    const regex = new RegExp(`\\s+${suffix}$`, 'gi');
    core = core.replace(regex, '').trim();
  }

  return core;
};

// Check if two company names match (strict matching)
const companyNamesMatch = (searchName, csvName) => {
  const n1 = normalizeCompanyName(searchName);
  const n2 = normalizeCompanyName(csvName);

  if (!n1 || !n2) return false;

  // Exact match after normalization
  if (n1 === n2) return true;

  // Extract core names (without suffixes)
  const core1 = extractCoreCompanyName(searchName);
  const core2 = extractCoreCompanyName(csvName);

  // Core names must match exactly
  if (core1 === core2 && core1.length > 0) return true;

  // For very short names (like "Teya"), require exact match of the core
  if (core1.length <= 5 || core2.length <= 5) {
    // Only match if one core is exactly the other (not just contains)
    return core1 === core2;
  }

  // For longer names, check if the search name is contained in CSV name
  // But only if it's at the start (to avoid false matches)
  if (core1.length > 5 && n2.startsWith(core1)) {
    return true;
  }

  if (core2.length > 5 && n1.startsWith(core2)) {
    return true;
  }

  return false;
};

// Search companies via background script (content scripts can't access extension IndexedDB)
const searchCompaniesInIndexedDB = async (companyName) => {
  try {
    console.log('[Badge Scanner] Sending search request to background script for:', companyName);

    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage(
        { type: 'SEARCH_VISA_SPONSOR', companyName },
        (response) => {
          if (chrome.runtime.lastError) {
            console.error('[Badge Scanner] Message error:', chrome.runtime.lastError);
            reject(chrome.runtime.lastError);
            return;
          }

          if (response && response.success) {
            console.log('[Badge Scanner] Received matches from background:', response.matches.length);
            resolve(response.matches);
          } else {
            console.error('[Badge Scanner] Search failed:', response?.error);
            resolve([]);
          }
        }
      );
    });
  } catch (error) {
    console.error('[Badge Scanner] Error searching IndexedDB:', error);
    return [];
  }
};

// Extract company name from the page
const extractCompanyName = () => {
  console.log('[LinkedIn Scraper] Attempting to extract company name...');

  // Try multiple selectors in order of reliability
  const selectors = [
    // Primary - the div with class and anchor inside
    { selector: '.job-details-jobs-unified-top-card__company-name a', name: 'Primary (div.company-name > a)' },
    { selector: '.job-details-jobs-unified-top-card__company-name', name: 'Primary (div.company-name)', getAnchor: true },
    // Alternative - look for any anchor with company link in the top card area
    { selector: '.job-details-jobs-unified-top-card__container--two-pane a[href*="/company/"]', name: 'Top card company link' },
    { selector: '.display-flex.align-items-center.flex-1 > div > a', name: 'Flex container anchor' },
    // Fallbacks
    { selector: '.jobs-unified-top-card__company-name a', name: 'Fallback 1' },
    { selector: '.jobs-unified-top-card__company-name', name: 'Fallback 2', getAnchor: true },
    { selector: 'a[data-tracking-control-name="public_jobs_topcard-org-name"]', name: 'Fallback 3' },
  ];

  for (const { selector, name, getAnchor } of selectors) {
    console.log(`[LinkedIn Scraper] Trying selector: ${name} (${selector})`);
    let el = document.querySelector(selector);

    if (el) {
      console.log(`[LinkedIn Scraper] Element found:`, el);

      // If we need to get anchor from inside the element
      if (getAnchor) {
        const anchor = el.querySelector('a');
        if (anchor) {
          el = anchor;
          console.log(`[LinkedIn Scraper] Found anchor inside:`, anchor);
        }
      }

      let companyName = (el.innerText || el.textContent || '').trim();
      console.log(`[LinkedIn Scraper] Raw text: "${companyName}"`);

      // Clean up the text
      companyName = companyName
        .replace(/\s*·\s*Follow\s*/gi, '')
        .replace(/\s*Follow\s*/gi, '')
        .replace(/\n/g, ' ')
        .trim();

      console.log(`[LinkedIn Scraper] Cleaned text: "${companyName}"`);

      if (companyName && companyName.length > 0 && companyName.length < 100) {
        console.log(`[LinkedIn Scraper] ✓ SUCCESS! Found company name: "${companyName}" using ${name}`);
        return companyName;
      }
    } else {
      console.log(`[LinkedIn Scraper] Element not found for: ${name}`);
    }
  }

  console.log('[LinkedIn Scraper] ❌ FAILED - Could not find company name with any selector');
  console.log('[LinkedIn Scraper] Available elements with "company" in class:',
    Array.from(document.querySelectorAll('[class*="company"]')).map(el => ({
      tag: el.tagName,
      class: el.className,
      text: (el.innerText || el.textContent || '').substring(0, 50)
    }))
  );

  return null;
};

// Wait for company name element to appear
const waitForCompanyName = (timeout = 3000) => {
  console.log('[LinkedIn Scraper] waitForCompanyName() called, timeout:', timeout);
  return new Promise((resolve) => {
    const startTime = Date.now();
    let attemptCount = 0;

    const checkCompanyName = () => {
      attemptCount++;
      console.log(`[LinkedIn Scraper] Attempt ${attemptCount} to extract company name...`);
      const companyName = extractCompanyName();

      if (companyName) {
        console.log(`[LinkedIn Scraper] ✓ Company name found after ${attemptCount} attempts:`, companyName);
        resolve(companyName);
        return;
      }

      // Keep trying until timeout
      const elapsed = Date.now() - startTime;
      if (elapsed < timeout) {
        console.log(`[LinkedIn Scraper] Retrying in 200ms... (${elapsed}ms elapsed)`);
        setTimeout(checkCompanyName, 200);
      } else {
        console.log(`[LinkedIn Scraper] ⏱ Timeout after ${attemptCount} attempts (${elapsed}ms)`);
        resolve(null);
      }
    };

    checkCompanyName();
  });
};

// Extract job details from the page
const extractJobDetails = async () => {
  console.log('[LinkedIn Scraper] extractJobDetails() called');

  // Based on actual HTML: .jobs-search__job-details--wrapper contains the job description
  const jobDetailsEl = document.querySelector('.jobs-search__job-details--wrapper') ||
                       document.querySelector('#job-details > div');

  if (!jobDetailsEl) {
    console.log('[LinkedIn Scraper] No job details element found');
    return null;
  }

  const text = jobDetailsEl.innerText || jobDetailsEl.textContent || '';
  const cleaned = normalizeText(text);

  // Extract job ID from URL - try multiple patterns
  const url = window.location.href;
  console.log('[Badge Scanner] Current URL:', url);

  let jobId = null;

  // Try different URL patterns
  const patterns = [
    /\/jobs\/view\/(\d+)/,           // /jobs/view/123456
    /\/jobs\/collections\/[^/]+\/(\d+)/, // /jobs/collections/recommended/123456
    /currentJobId=(\d+)/,             // ?currentJobId=123456
    /\/jobs\/search\/[^/]*\?currentJobId=(\d+)/, // /jobs/search/?currentJobId=123456
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      jobId = match[1];
      console.log('[Badge Scanner] Job ID extracted using pattern:', pattern, '→', jobId);
      break;
    }
  }

  if (!jobId) {
    console.log('[Badge Scanner] Could not extract job ID from URL');
  }

  // Only send if the content has changed
  if (cleaned && cleaned !== lastJobText) {
    console.log('[LinkedIn Scraper] New job text detected, length:', cleaned.length);
    lastJobText = cleaned;
    currentJobId = jobId;

    // Wait for company name to load (with timeout)
    console.log('[LinkedIn Scraper] Starting company name extraction...');
    const companyName = await waitForCompanyName(3000);
    console.log('[LinkedIn Scraper] Final company name:', companyName);

    // Trigger badge analysis for this job
    console.log('[Badge Scanner] Checking if should analyze job...');
    console.log('[Badge Scanner] - jobId:', jobId);
    console.log('[Badge Scanner] - badgeSettings:', badgeSettings);
    console.log('[Badge Scanner] - badgeSettings.enabled:', badgeSettings?.enabled);

    if (jobId && badgeSettings && badgeSettings.enabled) {
      console.log('[Badge Scanner] ✓ Triggering badge analysis');
      await analyzeCurrentJobAndUpdateBadges(jobId, cleaned);
    } else {
      console.log('[Badge Scanner] ✗ Skipping badge analysis');
      if (!jobId) console.log('[Badge Scanner]   - No job ID');
      if (!badgeSettings) console.log('[Badge Scanner]   - Badge settings not loaded');
      if (badgeSettings && !badgeSettings.enabled) console.log('[Badge Scanner]   - Badge scanner disabled');
    }

    return {
      text: cleaned,
      companyName: companyName
    };
  }

  console.log('[LinkedIn Scraper] Job text unchanged, skipping');
  return null;
};

// Send job data to the side panel
const sendJobDataToSidePanel = (jobData) => {
  chrome.runtime.sendMessage({
    type: 'JOB_DATA_UPDATED',
    data: {
      text: jobData.text,
      companyName: jobData.companyName,
      url: window.location.href,
      timestamp: Date.now()
    }
  }).catch((err) => {
    // Side panel might not be open yet, that's okay
    console.log('Could not send to side panel:', err.message);
  });
};

// Check for job details and send if found
const checkAndSendJobDetails = async () => {
  const jobData = await extractJobDetails();
  if (jobData) {
    console.log('Job details found, sending to side panel');
    console.log('Company name in job data:', jobData.companyName);
    sendJobDataToSidePanel(jobData);
  }
};
```

```
Uncaught (in promise) Error: Extension context invalidated.
Context
https://www.linkedin.com/jobs/collections/recommended/?currentJobId=4311393588
Stack Trace
content.js:306 (sendJobDataToSidePanel)
content.js:326 (checkAndSendJobDetails)
```